<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Envoyer de l’argent à Christophe</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            /* Reset/minimal layout */
            :root {
              --card-bg: #ffffff;
              --page-bg: #f3f4f6; /* gray-50 */
              --muted: #6b7280; /* gray-500 */
              --accent: #2563eb; /* blue-600 */
              --input-bg: #f8fafc; /* light */
              --card-radius: 1rem;
              --card-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
            }

            html, body {
                height: 100%;
                margin: 0;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                background: var(--page-bg);
                color: #111827;
            }

            .hidden {
                display: none !important;
            }

            /* Spinner full screen */
            .staticrypt-spinner-container {
                height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid #d1d5db; /* gray-300 */
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border { 100% { transform: rotate(360deg); } }

            /* Page wrapper */
            .staticrypt-content {
                min-height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 1.5rem;
                box-sizing: border-box;
            }

            .staticrypt-page {
                width: 100%;
                max-width: 420px;
                margin: 0 auto;
                box-sizing: border-box;
            }

            /* Card */
            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: var(--card-bg);
                border-radius: var(--card-radius);
                box-shadow: var(--card-shadow);
                padding: 1.25rem; /* 20px */
                text-align: center;
            }

            .staticrypt-title {
                margin: 0;
                font-size: 1.25rem;
                font-weight: 600;
                color: #111827;
            }

            .staticrypt-instructions p {
                margin: .25rem 0 0;
                color: var(--muted);
                font-size: 0.95rem;
            }

            .staticrypt-hr {
                margin: 1rem 0;
                border: 0;
                border-top: 1px solid #eef2f7;
            }

            /* Input */
            .staticrypt-password-container {
                position: relative;
                background: var(--input-bg);
                width: 100%;
                border-radius: 0.5rem;
                margin: 0 0 0.9rem;
                box-sizing: border-box;
                padding: 0.25rem;
            }

            .staticrypt-password-container input[type="password"],
            .staticrypt-password-container input[type="text"],
            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                background: transparent;
                border: 0;
                box-sizing: border-box;
                font-size: 1rem;
                outline: 0;
                padding: 0.75rem 3rem 0.75rem 0.75rem; /* leave room for icon on right */
                width: 100%;
                color: #111827;
            }

            /* Eye icon */
            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 0.8;
                position: absolute;
                right: 0.5rem;
                top: 50%;
                transform: translateY(-50%);
                width: 28px;
                display: block;
            }

            /* Button (blue theme to match main page) */
            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: none;
                outline: 0;
                background: var(--accent);
                width: 100%;
                border: 0;
                padding: 0.75rem;
                color: #ffffff;
                font-size: 1rem;
                cursor: pointer;
                border-radius: 0.5rem;
                font-weight: 600;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                filter: brightness(0.95);
            }

            /* Remember checkbox label */
            label.staticrypt-remember {
                display: flex;
                align-items: center;
                justify-content: center;
                margin-top: 0.25rem;
                gap: .5rem;
                color: var(--muted);
                font-size: 0.95rem;
            }

            label.staticrypt-remember input[type="checkbox"] {
                transform: scale(1.2);
            }

            /* Error text */
            #staticrypt-error {
                margin-top: 0.5rem;
                color: #dc2626; /* red-600 */
                font-size: 0.9rem;
            }

            /* Responsive tweaks */
            @media (max-width: 420px) {
                .staticrypt-form { padding: 1rem; }
                .staticrypt-password-container input { padding-right: 2.75rem; }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Envoyer de l’argent à Christophe</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Accès page" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b78a382b8366ba649ba9cf781a1f5b86cf07d971ccedc811c49e64505629d2c5232eb3276c81cd84887db70ed94e5362e828b93eda65c82f068efb4002e7c5c9b3f42127983ce6ed26953afadc185bca5d6e66c76ff6eaa2c47d4a1c370b2a6981e05a20f996b602e9fc34979db92baa618e8a8742e88383c8f944bf1b525cb4acece76c4b74d62be13e77d39145c26659306c7255ec645f14c1ba90afe94b8193f0b495eb22fba77f4b54b3bedd2f262388a2048723a330a43eda0098a4ac5b5a88b9c0670248cd0fd87281dd99fb99a4502e3009b8cc7047e9118cc1877354d3fb677fa71c2b77e91d0e99352d55a1b394e3e11f53878f9b419bc833ff69854978414365f087835fc93a76d26f0a127eb6a0585cd3d0991f04b007390959e5c383567e97281a17f771a77d0386aa7b9daa63ba008d4f28c5aaa77d5b4420e7eb75d2bece6c8892de8a4a8909a6c1f58d9a9abb9d736f195381fc9d6a1fc362828672382e1089bed665085e177f8e2b2e62e99d0642237540458b244cf8939e2c41693ab59da0850e2d5b8db605e81fa6ca907af6027808f9b63f44bc3e95b935a1e38c8a91be565bd4770c7a15c1434dc59b81dff8a2e418cbc654c23664cd922305da74147f86c5c471796804cb6c2f64e984f596d4932185b2130d4e6a13f761a4ac51f26495aae5c5050c2dcacc05e0f24ccb75a83bbd4630320d2f1465d75180fb043f6e24d456460d0172eb9a989099c74c95a8b2df94600d1767ea66d3882f9d1ed9a8f43066699cc94501be1e077d040fe80aee88d4e8e51b6e32b8815603e645b2e021759fa26add0a178ffac808218869c1e73a14b5af5a7f8dbca5cae59d888365bd7e6173d1f373f92216820df98cd5a660bb33f07c30d4bffeb7d03e6559c82b058cfa12f0d6c1931652110d7fd8ddfd7c84cd0f4ec68a4425c24a9e5aac360c081cd9a496789cde1ebfc5e3ecb94671878269cfe65bbfeefb2e176bf86781e861e45d40e345d339e8167f09c6db0c18cd3adcd5275285bc21c5282d5421aa5ef7eabb20f0fc5908dfe7e8fab81fce2676c761c9bf4e4bc473c58e5a6076c36e86c2d41471fceee7cdc770b23bb5ed6867bec8833e1e4b84214904e383a4c6764d93e8b05e7f54f8f06eee5bc40f87773452f9ee5f6addff8da0a4d4706d64012992e001399283a75df55434b1dff2d2aa1920b3ca073ab8157ea440f3a3947e7e0eba9a1f7a8529762a004b3bcd3aed4c5a975bb28a272351359032cbce6e4d1ce9c8d09798d30c34c00175ab9fce158b6b1fd84d964daf7ca517babf55309c03808976fe03c84188299df220df90ddb2e04e18f01607c0b7d550637ca7cd3b266531507cf9028cf5a1958b019f6f3ce8850d9fe4524aff978fb7eb6aa564e7b4242718d6bc9d1c63bba22448cbe012cdc6e4d3cd3e1f61b1e972b3dda8f5fba1782d9e036e56b572701cc70c03890625a575215b6313e99ce71834dc6279461732ccc4fbc99da92a37db812eaa81bf822f0dae50b75c77141b388bb45681503cca54e4ec190ff3810428ec56d45992bf9a04d030431b01ab5aac7b1538122a048b923a21d5bba67a00523ffb5466183169f7efbaa048389c26e974e551b8bbd2cdee0cb9aea49d2d220b5182d356a93a56179107adee4f676a3e2d73a73e345d8ba01176311d6f0e4fff475ce3fd1d37ff7b063c9058ba3c6113476a049fb53e2dbb8179cf8e2831ea98e7379c07bb89b23e02796dc2c51082c6022f1a789044c7f860d2e3c2e87d29967bd0c801ea1a502c7274dab1fada489fb94c11afa5ec515120fc85daa047e1fcecb043dc9265ffa0cdfe112faba501e4642630140796967eefb16ae88101ac8574922b5827264769eaf7f9da47658664584a8a044a5b988fbc46b90dc81c188f500be41d01c7ccad414b7278d11031bfeb0c20528d65d5e89efd4d2f90631f384ff2f1e2a1405420a0fe972109af402d8e49e361273255bc686a082cccc0df366238d574e2f224ea43352cf1e277e8591e3d1fa47303a8faaebab6d9400f619f115706c7d754b386557e1baa232ed83ec3eeceb7d2c7e85c9d74b4fc793ccc790568bb0b9465a83d973d1ae8cd0b9fb9c756f53e2d39eb69db6f8b369c3cc800f27677da7cc1bfe719a441d2e11211d04d70c09d95657ee8ea96d1d8ee0ca306a297413a8c565fb44f0a58bc6652e9cad14d27ca8e9dad6673f0509766aa56c4718eb8578cab2e21ab37516c675573cc4e5a096bc5a57fc4c0ddd741c5a6fb484e69b9c8090e5de248398a9ad35b41ac88c94d7bbbaac1b4185976ed84d598548567b5f9896e8a70109b17a2f8af14f957a2aab7924570cc9e1ce9fdd98f43fee2f043352445364e72f4f1b821eb90fc657d75d14aca648eb8786b03ee301c45f807aae68c70013d0c50b4f985c06ac56aa66fb307f3f2c70078fa36c7bdddf17e405208d385093bbc19fa4b6ea8ea7403db830e76cc7b39cb0ca50a46346337af0d858c9f1c97970bd238040d195979c16c7178f2f22b8342fefea834c2fd8e7f062623b86a404ffc00aff484f706b117c8007c666703f97d84c2a4b3dd5d9041185712d24b7236037315c4961cf603ff6ec05ff043bd9727d58a1002599adb3fff81ff6c280e491c974f70059e09785f460f60625b5cd25f10cc118170c1aab1ba5aaa80f6d5dcec1fef3a9896d47a902f962f520298978bc7c8044004facf9ce0b8a5b4bbba8531228db551f24f0f836d4b921998a128d1dfc94a61322fba63722d56bb5dce33f702ad4798b0032a9cad598c9a534f991e9aa7ac50e0b2d5634c62f8bdc5a4d7d33812a07158237218af7ac295568cc52fe6e3565d44997245b49dcfcdb53ed605d13ecbea1d2e5bc446a17cef8b54d10a93ac372c9302f905d082d54e900d7a2edf65ce2d45e5f5cdbf4d3cf84d4478a53d5b1c7f2ae19579a16bc436afb14bd2c6ee0546500a8b643eb7b145cff6185b59e1916fb67627f9b0529ff09a62f7fea26c9db78ab14927ef221b9cf562afe190282fb284b0e545d15f75b6cd5ed07fdb32da9ed593649f78e7785ca397c0b88e3609d07eed2729f32bda673bccc64d8b702f8fbb08eb8f2ae934705a6d6a1bb1f7e9a86ecfb9970fa2209ddc352edff256e9fd47f7bc07778837e0c417561e190de5fe6af96e251c378fce9c59f01beea3d41c71d3fa0d7fb1df7b5a46b99632fbf7e5faecd2f792432c6f1587210998aefc2dc522e673ac47c272f00f125d7bad7e08af1f3d37fe1327c2230cf2a518f53c96e5e34308462f3ae55d625c453573e44caf74fbd5930d46438b8df238a383888f60b40e4b327d2d665eacde6358704997019bd2a2d782035ae77fde03a892dbb125324dc7442097d8abc3b6db7539764668bec9f0e04c929bb839c70ca4c149d0e25bc503c7abcc4073371f862ac0910d2673a9fd6800413f1e72808da726d9f24b7a7d72571648814335c88460b117e4dabe1bbe89b8e3fa1f3ad618bf0dc65f535ecc78f15c78f11d557a55ed6eeaed0dab1fbafb8a03cd729a461a7927f8ff14ea7d2192dd755045410b22e6b5a941f012eb4230c512fb2a142343beea0bb43051f330620c143aafe7adcecf5614e08ea6a8eef76d1c05b021d63a5071e987de8f1d5923ecf5678e79e6a8ef4ec9d6bb5dfa10a24a749533d8de809ed63d9775d8e65c2912d7e5ef28dced2a04e6e4386c8b15c0005e7df9825906279900406e1f943d95dbb50d941fedec4b1612badc94e1fc58f5613dbbdd91ae003347659380e0056d7f9a1bece869d950eed8f14086a139e7718a0884a89f0e27a7268502b1b4eac907a41d53e932d2f4694c33f30eb0d62234c951a8578ff6aab3005417c78539db96eb30fb0d54ea34968455041d431da6e12f902458a8bd7884fd17d45d1ec8d9762a2ad89371134042f6fbe987efaf65d3f710f509c299680fa4d2fe9879aee13fb0ccd48abd6b6c14f53b8bc4f90d4c4c8433d437c25f1cc8d5a7cd3e03dbbd85fe6738ff235a3f4b0e81d77968f5c99d39caa8c62e15a94c676c8a7ead4e34628ec0c9c5763df2a1941ace90acd04b852feb1a37c567919bb0e3495c5ff8f7438de4e97caec0c031bfe64c790508b17ea1c55c280d423ee5318dfb33f855bbf5acb2fcf25b7435e22d53dc91de5aff4fd004d3cde9754fd53efa7e957b755a472ca96b42e544c01285092610bc89021370268f0ad81d3af72f589f7010f9d3bdc2a8ac88a41b0478ed0b51653a1a0f2d538642dafddd9cf0d2ff0b4b4e971b382e92df60bcc49840b1734cbf57f85811ae549466ce046c8b31da5cef6cd06226bc6e224cce1ba17ba5333f7c9096e28aba5f0a10012d008dc6d678757b3890df5554a134c5029614d407f78d79b5154034186f42e5a302020839b45116105d62bcfed12ac43c0ef0ce7643d9d2045d53f18a45af9b0228cffcb42c9b7a4a00e8447ebb69e9ac12b21443a70fb1c0689ba4116ddf2c252455579643eebf4152b263636f2faf0feb7f31f67a696cf6f3e82cd81e1d917532a43e55dc419bb33b156850eebe038130998121214aac2819b874f04ada34b593c9da77b1791677a2b518b2adce9d20848271331a584aebcce090e7828e00388c55e5f2d0e467b0d5579a0a227412a52e3a16afe9e5a8747b64f56bc70c8cc90c0aa56a64ad2256054ef50ae2a6521aab43d84a816b8f804886385db298ce9e562a022b532a86d8dd60e9950fe62d2007f9482f2e6042ba3b21a7fad22a866d40752469b2fa3b5c6d0d907b7a389b1afbeddae413cacdf5fe235d813efe105e3e995c881b8f709b7478638a23ba7d43b657085b46b702e78e5f7f9e31fb208fa780aa106e19da7566de21e85e2445010f79494c65ef84e869a1658e057710de4cc772dce821a5f673f4d8d76bf80c5647b5a439b9a00e320830da567558fb425aac8de5bd9e799e5e8e4ca59cf9845241a132caf8414923915ef5eabba1247353bedd699e4a36fe33b88337f682f36a62974c46ffa91b840f50ac40e5551cbd93506eb7a092e62ea03b74639872808197cee9b102da8c1dbcbdad80a02e80ebd035f28131d276de789648992dfa903d0d4c74fd2b887c08a116faaaeed11cf49013fe637f0885c3a27389f91e315c630eff9c8ef53c48234e5e89c202048fc75ba4c5c3ce8b4a354a6f051d93db0e16b8253bedecc0a61de4e6e961682a67507425f76ac805236786371330557ca8819fc866d0ab01e8a479836a3d368034a8b0f4def7f08f0226a99137e30b7671b22e7576c5321c124c75f2bedd459d20ca590d94de3c5a3d5129819faa8b659a074a04bcddd6acaabb9013886e795052dd3c22ec6c9ea4efe9445e8477b8d5a834b393263ee9c162992c8fa92a03fef8da3df100da3e4638d9ce764afeb96809eab48fca737a6a6e5d5af2a69b376e5601aa04b90448d14f856da36aa07dbbce08115f4fc0a09319b50ba2768688169dd53feedc498c501459ae1eba6d3c5e29c6fadd97ea1c824fd0e6462a4700195297c032621f646ce1599681f5ced1e748aa120364ded37c7c25e3b4368a6fa4f5e6a219c94ee1395ef9692e91135d271291434e6bb52e648cc01d1ff0a7571fa4611c3f3696a976eb88f459d6676a81f937eafe094cb4eb4e9a63032d7a63569307b1151108117e92e7c3439c10110fc08e3032e72093f41591665eec0b9cee40c94b439fa0b61fc1393521b8e5a873b51e4d0306fb7b2d29bfdfe8cf885d2e3138af4c2b9583f2535815f8f4c3f47a59b77f294d99e2ef7ffd4bec94be9aae583908adfa278002138fad406d3c7a8010071fc840606c609a8ff6ceb31c4892de08f6db51a15443cb120ad684f76e7d3b6ed04a994d3f1f73fa9b57e129094d8cd4e93f905073ff040d4276d224364470263a0f289fb309723e3aaf4576bf792c19755255c6fcce324b175beeb5d01a85886f2de6befc3be63bdf45daf35b817e87910a47a2cbd85475b740e78bd37c56a944571179343716137fe16ed17733048c723445cfcc594cef23bc6a3bfff8e1cf0c50635ecac6d8269943d13e356701116efe10c103c0bb4ea50a940b328f44b17ac23187c9647976ee841a47958a20e1f9892d05d056c7af64370839ce3662d2cebe301ed153af787adad7ca19e10f6d4f0570998b8a8a10f19a858d633ffa4af9eb7c4781377a287a4646b3770ace7eede045a3cb0a37f697366d596cde75a41f9a8392c2d2f73cb3b5cbeb1306c232218fa1c56414bfc18a4000d05f30d212f61b5b64ba108d8167532051ccc220ccaccb55dfd2e0eca19d994b287d074d193bfc4253b691ad1c0a2ae45ba5a9cc8cc4823184ce5185360051d95180c1cfc4b4c3d1904d09af610d453c423b6b2d58145007fce54a59c8a0d28d7dea81c0bb0da0f4d7a77728a7ca7a2fa6d39cae869a88edb27556aa6ee355a72878cd2acb860bf98c87cd219f668b73d39f50716d587bf7f473ffbc3d0d479a26f8677123b259a2bc82657872564f985f53fc964f640771a72ee3be655759aac08d14d70751c5ac902dd091e9fb26a228b9c58c57e7a6cfa33c33750c7202dd859472a16767208546cbf1cd9facb2f0d1da48c91eb9e7fc2173939456494f1b26fd1e116fdf6ae5ee322e871867355f6235087ddeef656fe69287b0c18335546301feae4d85e6901c478a884ddb58c3310bc22af24d85118a94a4b8a328e1f9fccbee21336e01567ba115a5cb5370da9e8a7a7fbd08ee47ce23fc3b8185df9eb39ab07823d5d2dbfcb0015975369e6b75d4c410a3c6a673e2211e94e0857b059282bed3f406ee30df4a05b39f496cfc6713cc8917a04cd266b8bbcc2f125089ea087b889603c9637ef66dfd51be9bb8bbc5a27b0bd770736c51","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8021e936163b02e621af4ef942c813e4"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
